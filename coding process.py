# -*- coding: utf-8 -*-
"""Neural Network.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16KeSWGxqzwf8sNovf5Rqhj6YkYYO13nd
"""

#Transform image to data

from PIL import Image
import numpy as np
import glob
import cv2 as cv
import random

def image_to_rgb_array(image_path, label, count):
    image = Image.open(image_path)
    filename = image.filename

    if("cloudy" in filename):
      label[count] = int(0)
      count+=1
    elif("rain" in filename):
      label[count] = int(1)
      count+=1
    else:
      label[count] = int(2)
      count+=1

    image = image.resize((100,100))
    width, height = image.size
    pixels = image.load()
    rgb_array = np.zeros((height, width, 3), dtype=np.uint8)

    for y in range(height):
        for x in range(width):
            r, g, b = pixels[x, y]
            rgb_array[y, x] = [r, g, b]

    return rgb_array, label, count

label = np.zeros((598),dtype=int)
count = 0

# Provide the directory containing the images
image_directory = "/content/drive/MyDrive/dataset2/dataset2/*.jpg"

# Gather all image file paths
image_files = glob.glob(image_directory)
image_files_shuffled = random.sample(image_files, len(image_files))

# Initialize an empty list to store the RGB arrays of all images
all_rgb_arrays = []

# Process each image and add its RGB values to the list
for image_file in image_files_shuffled:
    rgb_array, label, count = image_to_rgb_array(image_file,label,count)
    all_rgb_arrays.append(rgb_array)

# Convert the list to a NumPy array for easier manipulation (optional)
all_rgb_arrays = np.array(all_rgb_arrays)

np.save("weather_image.npy",all_rgb_arrays)
np.save("weather_label.npy",label)

print(all_rgb_arrays.shape)
print(label.shape)

#Flipping the label

col_vector = np.column_stack([row_vector])
label = col_vector
print(label.shape)

#Training stage

import cv2 as cv
import numpy as np
import matplotlib.pyplot as plt
from tensorflow import keras

training_images = all_rgb_arrays
testing_images = all_rgb_arrays[:360]
training_labels = label
testing_labels = label[:360]

#Normalize data
training_images, testing_images = training_images / 255, testing_images / 255

class_names = ['cloudy','rainy','sunny']

for i in range(16):
  plt.subplot(4,4,i+1)
  plt.xticks([])
  plt.yticks([])
  plt.imshow(training_images[i],cmap=plt.cm.binary)
  plt.xlabel(class_names[training_labels[i][0]])

model = keras.models.Sequential()
model.add(keras.layers.Conv2D(32, (3,3), activation = 'relu', input_shape=(100,100,3)))
model.add(keras.layers.MaxPooling2D((2,2)))
model.add(keras.layers.Conv2D(64,(3,3),activation = 'relu'))
model.add(keras.layers.MaxPooling2D(2,2))
model.add(keras.layers.Conv2D(64,(3,3),activation = 'relu'))
model.add(keras.layers.Flatten())
model.add(keras.layers.Dense(64,activation ='relu'))
model.add(keras.layers.Dense(3,activation ='softmax'))


model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])
model.fit(training_images, training_labels, batch_size=1, epochs=10, validation_data=(testing_images,testing_labels))

loss,accuracy = model.evaluate(testing_images, testing_labels)
print(f"Loss: {loss}")
print(f"Accuracy: {accuracy}")

model.save('weathering.model')

#Testing stage

import cv2 as cv
import numpy as np
import matplotlib.pyplot as plt
from tensorflow import keras

model = keras.models.load_model('/content/drive/MyDrive/weathering.model')

for i in range(5):
  pic = "p"+str(i+1)+".jpg"
  img = cv.imread(pic)
  img = cv.cvtColor(img, cv.COLOR_BGR2RGB)


  plt.imshow(img, cmap=plt.cm.binary)
  prediction = model.predict(np.array([img]) / 255)
  index = np.argmax(prediction)
  print(f'Prediction is {class_names[index]}')
  plt.show()
